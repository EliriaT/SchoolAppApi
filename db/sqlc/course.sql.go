// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: course.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const createCourse = `-- name: CreateCourse :one
INSERT INTO "Course"(
    name,teacher_id,semester_id,class_id
)VALUES (
            $1,$2,$3,$4
        ) RETURNING id, name, teacher_id, semester_id, class_id, dates, created_by, updated_by, created_at, updated_at
`

type CreateCourseParams struct {
	Name       string        `json:"name"`
	TeacherID  sql.NullInt64 `json:"teacherID"`
	SemesterID sql.NullInt32 `json:"semesterID"`
	ClassID    sql.NullInt32 `json:"classID"`
}

func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (Course, error) {
	row := q.db.QueryRowContext(ctx, createCourse,
		arg.Name,
		arg.TeacherID,
		arg.SemesterID,
		arg.ClassID,
	)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TeacherID,
		&i.SemesterID,
		&i.ClassID,
		pq.Array(&i.Dates),
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCoursesOfClass = `-- name: ListCoursesOfClass :many
SELECT id, name, teacher_id, semester_id, class_id, dates, created_by, updated_by, created_at, updated_at FROM "Course"
WHERE class_id = $1
ORDER BY name
LIMIT $2
OFFSET $3
`

type ListCoursesOfClassParams struct {
	ClassID sql.NullInt32 `json:"classID"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

func (q *Queries) ListCoursesOfClass(ctx context.Context, arg ListCoursesOfClassParams) ([]Course, error) {
	rows, err := q.db.QueryContext(ctx, listCoursesOfClass, arg.ClassID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Course{}
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TeacherID,
			&i.SemesterID,
			&i.ClassID,
			pq.Array(&i.Dates),
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoursesOfTeacher = `-- name: ListCoursesOfTeacher :many
SELECT id, name, teacher_id, semester_id, class_id, dates, created_by, updated_by, created_at, updated_at FROM "Course"
WHERE teacher_id = $1
ORDER BY name
LIMIT $2
OFFSET $3
`

type ListCoursesOfTeacherParams struct {
	TeacherID sql.NullInt64 `json:"teacherID"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (q *Queries) ListCoursesOfTeacher(ctx context.Context, arg ListCoursesOfTeacherParams) ([]Course, error) {
	rows, err := q.db.QueryContext(ctx, listCoursesOfTeacher, arg.TeacherID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Course{}
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TeacherID,
			&i.SemesterID,
			&i.ClassID,
			pq.Array(&i.Dates),
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCourseDates = `-- name: UpdateCourseDates :one
UPDATE  "Course"
SET  dates = $2, updated_at = now()
where id = $1
RETURNING id, name, teacher_id, semester_id, class_id, dates, created_by, updated_by, created_at, updated_at
`

type UpdateCourseDatesParams struct {
	ID    int64       `json:"id"`
	Dates []time.Time `json:"dates"`
}

func (q *Queries) UpdateCourseDates(ctx context.Context, arg UpdateCourseDatesParams) (Course, error) {
	row := q.db.QueryRowContext(ctx, updateCourseDates, arg.ID, pq.Array(arg.Dates))
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TeacherID,
		&i.SemesterID,
		&i.ClassID,
		pq.Array(&i.Dates),
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCourseTeacher = `-- name: UpdateCourseTeacher :one
UPDATE  "Course"
SET  teacher_id = $2, updated_at = now()
where id = $1
RETURNING id, name, teacher_id, semester_id, class_id, dates, created_by, updated_by, created_at, updated_at
`

type UpdateCourseTeacherParams struct {
	ID        int64         `json:"id"`
	TeacherID sql.NullInt64 `json:"teacherID"`
}

func (q *Queries) UpdateCourseTeacher(ctx context.Context, arg UpdateCourseTeacherParams) (Course, error) {
	row := q.db.QueryRowContext(ctx, updateCourseTeacher, arg.ID, arg.TeacherID)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TeacherID,
		&i.SemesterID,
		&i.ClassID,
		pq.Array(&i.Dates),
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
